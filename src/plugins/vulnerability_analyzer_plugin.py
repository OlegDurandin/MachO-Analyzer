from typing import Dict, Any, List
from core.plugin_base import MachOPlugin
from core.security_analyzer import SecurityIssue, SeverityLevel
from core.constants import (
    CPU_TYPE_X86,
    CPU_TYPE_X86_64,
    CPU_TYPE_ARM,
    CPU_TYPE_ARM64,
    CPU_TYPE_ARM64_32,
    CPU_TYPE_POWERPC,
    CPU_TYPE_POWERPC64
)
import re
from macholib.mach_o import *
from macholib.MachO import MachO
from macholib.mach_o import (
    MH_ALLOW_STACK_EXECUTION,
    MH_NO_HEAP_EXECUTION,
    MH_PIE,
    MH_NO_REEXPORTED_DYLIBS,
    MH_APP_EXTENSION_SAFE,
    S_ATTR_SOME_INSTRUCTIONS,
    LC_SEGMENT,
    LC_SEGMENT_64,
    LC_SYMTAB
)
from rich.console import Console
from rich.table import Table
from rich.panel import Panel

console = Console()

class VulnerabilityAnalyzerPlugin(MachOPlugin):
    """Плагин для анализа уязвимостей и точек инъекции в Mach-O файлах"""
    
    def __init__(self, macho, file_path: str):
        super().__init__(macho, file_path)
        
        # Паттерны для поиска небезопасных функций
        self.unsafe_functions = {
            "buffer_overflow": [
                b"strcpy",
                b"strcat",
                b"gets",
                b"sprintf",
                b"vsprintf",
                b"scanf",
                b"fscanf",
                b"sscanf",
                b"vscanf",
                b"vsscanf",
                b"vfscanf",
                b"realpath",
                b"syslog",
                b"getwd",
                b"streadd",
                b"strecpy",
                b"strtrns"
            ],
            "format_string": [
                b"printf",
                b"fprintf",
                b"sprintf",
                b"snprintf",
                b"vprintf",
                b"vfprintf",
                b"vsprintf",
                b"vsnprintf"
            ],
            "command_injection": [
                b"system",
                b"popen",
                b"execl",
                b"execlp",
                b"execle",
                b"execv",
                b"execvp",
                b"execvpe"
            ],
            "memory_corruption": [
                b"memcpy",
                b"memmove",
                b"memset",
                b"malloc",
                b"free",
                b"realloc",
                b"alloca"
            ]
        }
        
        # Паттерны для поиска точек инъекции
        self.injection_points = {
            "dyld": [
                b"DYLD_INSERT_LIBRARIES",
                b"DYLD_LIBRARY_PATH",
                b"DYLD_FRAMEWORK_PATH",
                b"DYLD_FORCE_FLAT_NAMESPACE"
            ],
            "runtime": [
                b"dlopen",
                b"dlsym",
                b"dyld_image_path_containing_address",
                b"_dyld_get_image_name",
                b"_dyld_register_func_for_add_image"
            ],
            "process_injection": [
                b"task_for_pid",
                b"mach_vm_allocate",
                b"mach_vm_write",
                b"mach_vm_protect",
                b"thread_create",
                b"thread_set_state"
            ],
            "hooks": [
                b"ptrace",
                b"mach_msg",
                b"interceptor_begin",
                b"method_exchangeImplementations",
                b"method_setImplementation"
            ]
        }
        
        # Паттерны для поиска уязвимых конфигураций
        self.vulnerable_configs = {
            "security_flags": [
                b"_FORTIFY_SOURCE",
                b"stack_chk_guard",
                b"stack_chk_fail",
                b"fstack-protector",
                b"allow_stack_execute",
                b"restricted",
                b"ASLR"
            ],
            "debugging": [
                b"PT_DENY_ATTACH",
                b"sysctl",
                b"ptrace",
                b"isatty",
                b"ioctl",
                b"ttyname"
            ]
        }
    
    def analyze(self) -> Dict[str, Any]:
        """Анализирует уязвимости в Mach-O файле"""
        results = {
            "basic_info": {
                "total_vulnerabilities": 0,
                "critical_vulnerabilities": 0,
                "warning_vulnerabilities": 0,
                "info_vulnerabilities": 0
            },
            "vulnerability_analysis": {
                "header_flags": [],
                "executable_sections": [],
                "unsafe_functions": [],
                "injection_points": [],
                "vulnerable_configs": []
            },
            "risk_assessment": {
                "level": "INFO",
                "reasons": [],
                "recommendations": []
            }
        }
        
        try:
            for header in self.macho.headers:
                # Анализ флагов заголовка
                header_issues = self._analyze_header_flags(header)
                results["vulnerability_analysis"]["header_flags"].extend(header_issues)
                
                # Анализ исполняемых секций
                section_issues = self._analyze_executable_sections(header)
                results["vulnerability_analysis"]["executable_sections"].extend(section_issues)
                
                # Анализ небезопасных функций
                function_issues = self._analyze_unsafe_functions(header)
                results["vulnerability_analysis"]["unsafe_functions"].extend(function_issues)
                
                # Анализ точек инъекции
                injection_issues = self._analyze_injection_points(header)
                results["vulnerability_analysis"]["injection_points"].extend(injection_issues)
                
                # Анализ уязвимых конфигураций
                config_issues = self._analyze_vulnerable_configs(header)
                results["vulnerability_analysis"]["vulnerable_configs"].extend(config_issues)
            
            # Обновляем статистику
            self._update_stats(results)
            
            # Оцениваем риски
            self._assess_risks(results)
            
        except Exception as e:
            console.print(f"[red]Ошибка при анализе уязвимостей: {str(e)}[/red]")
            
        return results
    
    def _analyze_header_flags(self, header) -> List[SecurityIssue]:
        """Анализирует флаги заголовка на наличие уязвимостей"""
        issues = []
        
        if header.header.flags & MH_ALLOW_STACK_EXECUTION:
            issues.append(SecurityIssue(
                description="Разрешено выполнение кода в стеке",
                severity=SeverityLevel.CRITICAL,
                details="Флаг MH_ALLOW_STACK_EXECUTION установлен в заголовке файла",
                is_problem=True,
                recommendation="Отключить выполнение кода в стеке для предотвращения атак"
            ))
            
        if header.header.flags & MH_NO_HEAP_EXECUTION:
            issues.append(SecurityIssue(
                description="Запрещено выполнение кода в куче",
                severity=SeverityLevel.INFO,
                details="Флаг MH_NO_HEAP_EXECUTION установлен в заголовке файла",
                is_problem=False,
                recommendation="Рекомендуется оставить этот флаг для дополнительной безопасности"
            ))
            
        if not (header.header.flags & MH_PIE):
            issues.append(SecurityIssue(
                description="Отключен ASLR (Address Space Layout Randomization)",
                severity=SeverityLevel.CRITICAL,
                details="Флаг MH_PIE не установлен в заголовке файла",
                is_problem=True,
                recommendation="Включить ASLR для предотвращения атак на переполнение буфера"
            ))
            
        if not (header.header.flags & MH_NO_REEXPORTED_DYLIBS):
            issues.append(SecurityIssue(
                description="Разрешено реэкспортирование динамических библиотек",
                severity=SeverityLevel.WARNING,
                details="Флаг MH_NO_REEXPORTED_DYLIBS не установлен в заголовке файла",
                is_problem=True,
                recommendation="Ограничить реэкспортирование библиотек для предотвращения DLL-инъекций"
            ))
            
        if header.header.flags & MH_APP_EXTENSION_SAFE:
            issues.append(SecurityIssue(
                description="Приложение безопасно для расширений",
                severity=SeverityLevel.INFO,
                details="Флаг MH_APP_EXTENSION_SAFE установлен в заголовке файла",
                is_problem=False,
                recommendation="Рекомендуется оставить этот флаг для дополнительной безопасности"
            ))
            
        return issues
    
    def _analyze_executable_sections(self, header) -> List[SecurityIssue]:
        """Анализирует исполняемые секции на наличие уязвимостей"""
        issues = []
        
        for cmd in header.commands:
            if cmd[0].cmd in (LC_SEGMENT, LC_SEGMENT_64):
                for sect in cmd[2]:
                    if sect.flags & S_ATTR_SOME_INSTRUCTIONS:
                        sect_name = sect.sectname.decode('utf-8').strip('\x00')
                        issues.append(SecurityIssue(
                            description="Найдена исполняемая секция " + sect_name,
                            severity=SeverityLevel.WARNING,
                            details=f"Секция {sect_name} имеет флаг S_ATTR_SOME_INSTRUCTIONS",
                            is_problem=True,
                            recommendation="Проверить необходимость исполняемых секций"
                        ))
        
        return issues
    
    def _analyze_unsafe_functions(self, header) -> List[SecurityIssue]:
        """Анализирует наличие небезопасных функций"""
        issues = []
        
        # Находим таблицу символов
        symtab_cmd = None
        for cmd in header.commands:
            if cmd[0].cmd == LC_SYMTAB:
                symtab_cmd = cmd[1]
                break
                
        if not symtab_cmd:
            return issues
            
        try:
            with open(self.file_path, 'rb') as f:
                # Читаем таблицу строк
                f.seek(symtab_cmd.stroff)
                string_table = f.read(symtab_cmd.strsize)
                
                # Декодируем таблицу строк
                decoded_strings = string_table.decode('utf-8', errors='ignore')
                
                # Проверяем функции переполнения буфера
                for func in self.unsafe_functions["buffer_overflow"]:
                    if func.decode('utf-8') in decoded_strings:
                        issues.append(SecurityIssue(
                            description="Найдена уязвимость переполнения буфера",
                            severity=SeverityLevel.CRITICAL,
                            details=f"Обнаружена небезопасная функция {func.decode('utf-8')}",
                            is_problem=True,
                            recommendation="Проверить обработку входных данных"
                        ))
                
                # Проверяем функции форматирования строк
                for func in self.unsafe_functions["format_string"]:
                    if func.decode('utf-8') in decoded_strings:
                        issues.append(SecurityIssue(
                            description="Найдена уязвимость форматирования строк",
                            severity=SeverityLevel.CRITICAL,
                            details=f"Обнаружена небезопасная функция {func.decode('utf-8')}",
                            is_problem=True,
                            recommendation="Использовать безопасные функции форматирования"
                        ))
                
                # Проверяем функции инъекции команд
                for func in self.unsafe_functions["command_injection"]:
                    if func.decode('utf-8') in decoded_strings:
                        issues.append(SecurityIssue(
                            description="Возможная уязвимость инъекции команд",
                            severity=SeverityLevel.CRITICAL,
                            details=f"Обнаружена небезопасная функция {func.decode('utf-8')}",
                            is_problem=True,
                            recommendation="Проверить обработку пользовательского ввода"
                        ))
                
                # Проверяем функции работы с памятью
                for func in self.unsafe_functions["memory_corruption"]:
                    if func.decode('utf-8') in decoded_strings:
                        issues.append(SecurityIssue(
                            description="Возможная уязвимость повреждения памяти",
                            severity=SeverityLevel.WARNING,
                            details=f"Обнаружена небезопасная функция {func.decode('utf-8')}",
                            is_problem=True,
                            recommendation="Проверить управление памятью"
                        ))
                        
        except (IOError, OSError) as e:
            console.print(f"[red]Ошибка при чтении таблицы символов: {str(e)}[/red]")
            
        return issues
    
    def _analyze_injection_points(self, header) -> List[SecurityIssue]:
        """Анализирует наличие точек инъекции"""
        issues = []
        
        for cmd in header.commands:
            if cmd[0].cmd in (LC_SEGMENT, LC_SEGMENT_64):
                for sect in cmd[2]:
                    sect_name = sect.sectname.decode('utf-8').strip('\x00')
                    
                    # Проверяем точки инъекции DYLD
                    for point in self.injection_points["dyld"]:
                        if point.decode('utf-8') in sect_name:
                            issues.append(SecurityIssue(
                                description="Обнаружена точка инъекции DYLD",
                                severity=SeverityLevel.CRITICAL,
                                details=f"Обнаружен маркер {point.decode('utf-8')}",
                                is_problem=True,
                                recommendation="Проверить настройки безопасности DYLD"
                            ))
                    
                    # Проверяем точки инъекции runtime
                    for point in self.injection_points["runtime"]:
                        if point.decode('utf-8') in sect_name:
                            issues.append(SecurityIssue(
                                description="Обнаружена точка инъекции runtime",
                                severity=SeverityLevel.WARNING,
                                details=f"Обнаружен маркер {point.decode('utf-8')}",
                                is_problem=True,
                                recommendation="Проверить механизмы защиты runtime"
                            ))
                    
                    # Проверяем точки инъекции процесса
                    for point in self.injection_points["process_injection"]:
                        if point.decode('utf-8') in sect_name:
                            issues.append(SecurityIssue(
                                description="Обнаружена точка инъекции процесса",
                                severity=SeverityLevel.CRITICAL,
                                details=f"Обнаружен маркер {point.decode('utf-8')}",
                                is_problem=True,
                                recommendation="Проверить механизмы защиты процесса"
                            ))
                    
                    # Проверяем точки хуков
                    for point in self.injection_points["hooks"]:
                        if point.decode('utf-8') in sect_name:
                            issues.append(SecurityIssue(
                                description="Обнаружена точка хука",
                                severity=SeverityLevel.WARNING,
                                details=f"Обнаружен маркер {point.decode('utf-8')}",
                                is_problem=True,
                                recommendation="Проверить механизмы защиты от хуков"
                            ))
        
        return issues
    
    def _analyze_vulnerable_configs(self, header) -> List[SecurityIssue]:
        """Анализирует наличие уязвимых конфигураций"""
        issues = []
        
        for cmd in header.commands:
            if cmd[0].cmd in (LC_SEGMENT, LC_SEGMENT_64):
                for sect in cmd[2]:
                    sect_name = sect.sectname.decode('utf-8').strip('\x00')
                    
                    # Проверяем флаги безопасности
                    for flag in self.vulnerable_configs["security_flags"]:
                        if flag.decode('utf-8') in sect_name:
                            issues.append(SecurityIssue(
                                description="Обнаружена уязвимая конфигурация безопасности",
                                severity=SeverityLevel.WARNING,
                                details=f"Обнаружен маркер {flag.decode('utf-8')}",
                                is_problem=True,
                                recommendation="Проверить настройки безопасности"
                            ))
                    
                    # Проверяем отладочные маркеры
                    for marker in self.vulnerable_configs["debugging"]:
                        if marker.decode('utf-8') in sect_name:
                            issues.append(SecurityIssue(
                                description="Обнаружен отладочный маркер",
                                severity=SeverityLevel.WARNING,
                                details=f"Обнаружен маркер {marker.decode('utf-8')}",
                                is_problem=True,
                                recommendation="Удалить отладочные маркеры"
                            ))
        
        return issues
    
    def _update_stats(self, results: Dict[str, Any]) -> None:
        """Обновляет статистику анализа"""
        total = 0
        critical = 0
        warning = 0
        info = 0
        
        for section in results["vulnerability_analysis"].values():
            for issue in section:
                total += 1
                if issue.severity == SeverityLevel.CRITICAL:
                    critical += 1
                elif issue.severity == SeverityLevel.WARNING:
                    warning += 1
                else:
                    info += 1
        
        results["basic_info"].update({
            "total_vulnerabilities": total,
            "critical_vulnerabilities": critical,
            "warning_vulnerabilities": warning,
            "info_vulnerabilities": info
        })
    
    def _assess_risks(self, results: Dict[str, Any]) -> None:
        """Оценивает риски на основе анализа"""
        risk_level = "INFO"
        reasons = []
        recommendations = []
        
        # Оценка на основе критических уязвимостей
        if results["basic_info"]["critical_vulnerabilities"] > 0:
            risk_level = "CRITICAL"
            reasons.append(f"Обнаружены критические уязвимости ({results['basic_info']['critical_vulnerabilities']})")
            recommendations.append("Немедленно исправить критические уязвимости")
        
        # Оценка на основе предупреждений
        elif results["basic_info"]["warning_vulnerabilities"] > 5:
            risk_level = "WARNING"
            reasons.append(f"Обнаружено значительное количество предупреждений ({results['basic_info']['warning_vulnerabilities']})")
            recommendations.append("Проверить и исправить предупреждения")
        
        # Оценка на основе исполняемых секций
        if len(results["vulnerability_analysis"]["executable_sections"]) > 3:
            if risk_level == "INFO":
                risk_level = "WARNING"
            reasons.append(f"Обнаружено значительное количество исполняемых секций ({len(results['vulnerability_analysis']['executable_sections'])})")
            recommendations.append("Проверить необходимость исполняемых секций")
        
        # Оценка на основе точек инъекции
        if len(results["vulnerability_analysis"]["injection_points"]) > 2:
            if risk_level == "INFO":
                risk_level = "WARNING"
            reasons.append(f"Обнаружено значительное количество точек инъекции ({len(results['vulnerability_analysis']['injection_points'])})")
            recommendations.append("Усилить механизмы защиты от инъекций")
        
        results["risk_assessment"].update({
            "level": risk_level,
            "reasons": reasons,
            "recommendations": recommendations
        })
    
    def _print_vulnerability_info(self, results: Dict[str, Any]) -> None:
        """Выводит информацию об уязвимостях"""
        try:
            # Основная информация
            console.print("\n[bold magenta]Основная информация о потенциальныхуязвимостях[/bold magenta]")
            basic_table = Table(show_header=True, header_style="bold magenta")
            basic_table.add_column("Параметр", style="cyan")
            basic_table.add_column("Значение", style="yellow")
            
            basic_rows = [
                ["Всего уязвимостей", str(results["basic_info"]["total_vulnerabilities"])],
                ["Критических", str(results["basic_info"]["critical_vulnerabilities"])],
                ["Предупреждений", str(results["basic_info"]["warning_vulnerabilities"])],
                ["Информационных", str(results["basic_info"]["info_vulnerabilities"])]
            ]
            
            for row in basic_rows:
                basic_table.add_row(*row)
            console.print(basic_table)
            
            # Флаги заголовка
            if results["vulnerability_analysis"]["header_flags"]:
                console.print("\n[bold cyan]Флаги заголовка[/bold cyan]")
                flag_table = Table(show_header=True, header_style="bold cyan")
                flag_table.add_column("Описание", style="cyan")
                flag_table.add_column("Уровень", style="yellow")
                flag_table.add_column("Детали", style="white")
                flag_table.add_column("Рекомендация", style="green")
                
                for issue in results["vulnerability_analysis"]["header_flags"]:
                    flag_table.add_row(
                        issue.description,
                        issue.severity.value,
                        issue.details,
                        issue.recommendation
                    )
                console.print(flag_table)
            
            # Исполняемые секции
            if results["vulnerability_analysis"]["executable_sections"]:
                console.print("\n[bold yellow]Исполняемые секции[/bold yellow]")
                section_table = Table(show_header=True, header_style="bold yellow")
                section_table.add_column("Описание", style="yellow")
                section_table.add_column("Уровень", style="yellow")
                section_table.add_column("Детали", style="white")
                section_table.add_column("Рекомендация", style="green")
                
                for issue in results["vulnerability_analysis"]["executable_sections"]:
                    section_table.add_row(
                        issue.description,
                        issue.severity.value,
                        issue.details,
                        issue.recommendation
                    )
                console.print(section_table)
            
            # Небезопасные функции
            if results["vulnerability_analysis"]["unsafe_functions"]:
                console.print("\n[bold red]Небезопасные функции[/bold red]")
                function_table = Table(show_header=True, header_style="bold red")
                function_table.add_column("Описание", style="red")
                function_table.add_column("Уровень", style="yellow")
                function_table.add_column("Детали", style="white")
                function_table.add_column("Рекомендация", style="green")
                
                for issue in results["vulnerability_analysis"]["unsafe_functions"]:
                    function_table.add_row(
                        issue.description,
                        issue.severity.value,
                        issue.details,
                        issue.recommendation
                    )
                console.print(function_table)
            
            # Точки инъекции
            if results["vulnerability_analysis"]["injection_points"]:
                console.print("\n[bold red]Точки инъекции[/bold red]")
                injection_table = Table(show_header=True, header_style="bold red")
                injection_table.add_column("Описание", style="red")
                injection_table.add_column("Уровень", style="yellow")
                injection_table.add_column("Детали", style="white")
                injection_table.add_column("Рекомендация", style="green")
                
                for issue in results["vulnerability_analysis"]["injection_points"]:
                    injection_table.add_row(
                        issue.description,
                        issue.severity.value,
                        issue.details,
                        issue.recommendation
                    )
                console.print(injection_table)
            
            # Уязвимые конфигурации
            if results["vulnerability_analysis"]["vulnerable_configs"]:
                console.print("\n[bold yellow]Уязвимые конфигурации[/bold yellow]")
                config_table = Table(show_header=True, header_style="bold yellow")
                config_table.add_column("Описание", style="yellow")
                config_table.add_column("Уровень", style="yellow")
                config_table.add_column("Детали", style="white")
                config_table.add_column("Рекомендация", style="green")
                
                for issue in results["vulnerability_analysis"]["vulnerable_configs"]:
                    config_table.add_row(
                        issue.description,
                        issue.severity.value,
                        issue.details,
                        issue.recommendation
                    )
                console.print(config_table)
            
            # Оценка рисков
            if results["risk_assessment"]["reasons"]:
                console.print("\n[bold red]Оценка рисков[/bold red]")
                risk_table = Table(show_header=True, header_style="bold red")
                risk_table.add_column("Уровень", style="red")
                risk_table.add_column("Причины", style="yellow")
                risk_table.add_column("Рекомендации", style="green")
                
                risk_table.add_row(
                    results["risk_assessment"]["level"],
                    "\n".join(results["risk_assessment"]["reasons"]),
                    "\n".join(results["risk_assessment"]["recommendations"])
                )
                console.print(risk_table)
                
        except Exception as e:
            console.print(f"[red]Ошибка при выводе информации об уязвимостях: {str(e)}[/red]")
    
    @staticmethod
    def get_name() -> str:
        return "vulnerability_analyzer"
    
    @staticmethod
    def get_description() -> str:
        return "Анализирует Mach-O файл на наличие уязвимостей и точек инъекции"
    
    @staticmethod
    def get_version() -> str:
        return "1.0.0"
    
    @staticmethod
    def is_compatible() -> bool:
        return True

    def _check_stack_protection(self, header: Any) -> List[SecurityIssue]:
        """Проверяет защиту стека"""
        issues = []
        
        # Проверяем флаг NX_STACK
        if not (header.header.flags & 0x10000000):  # MH_NX_STACK
            issues.append(SecurityIssue(
                description="Стек не защищен от выполнения (NX)",
                severity=SeverityLevel.CRITICAL,
                details="Флаг MH_NX_STACK (0x10000000) не установлен в заголовке файла",
                is_problem=True,
                recommendation="Рекомендуется включить защиту стека от выполнения"
            ))
        
        return issues

    def _check_buffer_overflow(self, header: Any) -> List[SecurityIssue]:
        """Проверяет наличие уязвимостей переполнения буфера"""
        issues = []
        
        # Проверяем наличие небезопасных функций
        for unsafe_function in self.unsafe_functions["buffer_overflow"]:
            if unsafe_function in header.segname:
                issues.append(SecurityIssue(
                    description="Найдена уязвимость переполнения буфера",
                    severity=SeverityLevel.CRITICAL,
                    details=f"Обнаружена небезопасная функция {unsafe_function.decode('utf-8')}",
                    is_problem=True,
                    recommendation="Проверить обработку входных данных"
                ))
        
        return issues

    def _check_format_string(self, header: Any) -> List[SecurityIssue]:
        """Проверяет наличие уязвимостей форматной строки"""
        issues = []
        
        # Проверяем наличие небезопасных функций
        for unsafe_function in self.unsafe_functions["format_string"]:
            if unsafe_function in header.segname:
                issues.append(SecurityIssue(
                    description="Возможная уязвимость форматной строки",
                    severity=SeverityLevel.WARNING,
                    details=f"Обнаружена небезопасная функция форматирования {unsafe_function.decode('utf-8')}",
                    is_problem=True,
                    recommendation="Использовать безопасные функции форматирования"
                ))
        
        return issues

    def _check_integer_overflow(self, header: Any) -> List[SecurityIssue]:
        """Проверяет наличие уязвимостей целочисленного переполнения"""
        issues = []
        
        # Проверяем наличие небезопасных функций
        for unsafe_function in self.unsafe_functions["memory_corruption"]:
            if unsafe_function in header.segname:
                issues.append(SecurityIssue(
                    description="Найдена уязвимость целочисленного переполнения",
                    severity=SeverityLevel.CRITICAL,
                    details=f"Обнаружена небезопасная функция работы с памятью {unsafe_function.decode('utf-8')}",
                    is_problem=True,
                    recommendation="Добавить проверки границ"
                ))
        
        return issues

    def _check_race_condition(self, header: Any) -> List[SecurityIssue]:
        """Проверяет наличие уязвимостей race condition"""
        issues = []
        
        # Проверяем наличие небезопасных функций
        for unsafe_function in self.unsafe_functions["memory_corruption"]:
            if unsafe_function in header.segname:
                issues.append(SecurityIssue(
                    description="Возможная уязвимость race condition",
                    severity=SeverityLevel.WARNING,
                    details=f"Обнаружена потенциально небезопасная функция {unsafe_function.decode('utf-8')}",
                    is_problem=True,
                    recommendation="Использовать синхронизацию"
                ))
        
        return issues

    def _check_use_after_free(self, header: Any) -> List[SecurityIssue]:
        """Проверяет наличие уязвимостей использования после освобождения"""
        issues = []
        
        # Проверяем наличие небезопасных функций
        for unsafe_function in self.unsafe_functions["memory_corruption"]:
            if unsafe_function in header.segname:
                issues.append(SecurityIssue(
                    description="Найдена уязвимость использования после освобождения",
                    severity=SeverityLevel.WARNING,
                    details=f"Обнаружена небезопасная функция управления памятью {unsafe_function.decode('utf-8')}",
                    is_problem=True,
                    recommendation="Проверить управление памятью"
                ))
        
        return issues

    def _check_double_free(self, header: Any) -> List[SecurityIssue]:
        """Проверяет наличие уязвимостей double free"""
        issues = []
        
        # Проверяем наличие небезопасных функций
        for unsafe_function in self.unsafe_functions["memory_corruption"]:
            if unsafe_function in header.segname:
                issues.append(SecurityIssue(
                    description="Возможная уязвимость double free",
                    severity=SeverityLevel.WARNING,
                    details=f"Обнаружена потенциально небезопасная функция освобождения памяти {unsafe_function.decode('utf-8')}",
                    is_problem=True,
                    recommendation="Проверить освобождение памяти"
                ))
        
        return issues 