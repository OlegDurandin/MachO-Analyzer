from typing import Dict, Any, List
from core.plugin_base import MachOPlugin
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from core.security_analyzer import SeverityLevel
from macholib.mach_o import (
    LC_SEGMENT, LC_SEGMENT_64, MH_MAGIC_64, MH_CIGAM_64
)
import re

console = Console()

class MalwarePatternsPlugin(MachOPlugin):
    """Плагин для анализа подозрительных паттернов в Mach-O файлах"""
    
    def __init__(self, macho, file_path: str):
        super().__init__(macho, file_path)
        self.suspicious_patterns = {
            "anti_debug": [
                r"ptrace",
                r"sysctl",
                r"task_for_pid",
                r"isatty",
                r"ioctl",
                r"getppid",
                r"fork",
                r"waitpid"
            ],
            "network": [
                r"socket",
                r"connect",
                r"bind",
                r"listen",
                r"accept",
                r"send",
                r"recv",
                r"inet_addr",
                r"gethostbyname"
            ],
            "file_ops": [
                r"open",
                r"write",
                r"read",
                r"unlink",
                r"rename",
                r"chmod",
                r"chown",
                r"mkdir",
                r"rmdir"
            ],
            "process": [
                r"exec",
                r"system",
                r"popen",
                r"vfork",
                r"kill",
                r"signal",
                r"setuid",
                r"setgid"
            ],
            "crypto": [
                r"crypto",
                r"openssl",
                r"aes",
                r"des",
                r"rc4",
                r"md5",
                r"sha1",
                r"sha256"
            ],
            "shell": [
                r"/bin/sh",
                r"/bin/bash",
                r"cmd",
                r"shell",
                r"sh -c",
                r"bash -c"
            ]
        }
        
        # Определяем числовые значения для уровней риска
        self.risk_levels = {
            SeverityLevel.INFO: 0,
            SeverityLevel.WARNING: 1,
            SeverityLevel.CRITICAL: 2
        }
    
    def analyze(self) -> Dict[str, Any]:
        """Анализирует файл на наличие подозрительных паттернов"""
        results = {
            "basic_info": {
                "total_patterns": 0,
                "total_categories": 0,
                "risk_level": SeverityLevel.INFO
            },
            "pattern_analysis": {
                "categories": {},
                "locations": []
            },
            "risk_assessment": {
                "level": SeverityLevel.INFO,
                "reasons": [],
                "recommendations": []
            }
        }
        
        # Анализ сегментов
        for header in self.macho.headers:
            for cmd in header.commands:
                if cmd[0].cmd in (LC_SEGMENT, LC_SEGMENT_64):
                    segment = cmd[1]
                    try:
                        segname = segment.segname.decode('utf-8').strip('\x00')
                        if segname in ['__TEXT', '__DATA']:
                            with open(self.file_path, 'rb') as f:
                                f.seek(segment.fileoff)
                                data = f.read(segment.filesize)
                                if data:
                                    # Поиск подозрительных строк в сегменте
                                    for pattern_type, patterns in self.suspicious_patterns.items():
                                        found_patterns = []
                                        for pattern in patterns:
                                            if self._search_pattern(data, pattern):
                                                found_patterns.append({
                                                    "pattern": pattern,
                                                    "description": self._get_pattern_description(pattern_type, pattern)
                                                })
                                        if found_patterns:
                                            results["pattern_analysis"]["categories"][pattern_type] = found_patterns
                                            results["basic_info"]["total_patterns"] += len(found_patterns)
                                            results["basic_info"]["total_categories"] += 1
                                            results["pattern_analysis"]["locations"].append({
                                                "segment": segname,
                                                "offset": hex(segment.fileoff),
                                                "size": segment.filesize,
                                                "category": pattern_type
                                            })
                    except Exception as e:
                        console.print(f"[yellow]Предупреждение: Ошибка при чтении сегмента {segname}: {str(e)}[/yellow]")
                        continue
        
        # Оценка рисков
        self._assess_risks(results)
        
        return results
    
    def _assess_risks(self, results: Dict[str, Any]) -> None:
        """Оценивает риски на основе анализа"""
        risk_level = SeverityLevel.INFO
        reasons = []
        recommendations = []
        
        # Оценка на основе количества паттернов
        if results["basic_info"]["total_patterns"] > 10:
            risk_level = SeverityLevel.CRITICAL
            reasons.append(f"Обнаружено большое количество подозрительных паттернов ({results['basic_info']['total_patterns']})")
            recommendations.append("Требуется детальный анализ файла")
            recommendations.append("Рекомендуется запуск в изолированной среде")
        elif results["basic_info"]["total_patterns"] > 5:
            risk_level = SeverityLevel.WARNING
            reasons.append(f"Обнаружено значительное количество подозрительных паттернов ({results['basic_info']['total_patterns']})")
            recommendations.append("Рекомендуется дополнительный анализ")
        
        # Оценка на основе категорий
        if results["basic_info"]["total_categories"] > 3:
            if self.risk_levels[risk_level] < self.risk_levels[SeverityLevel.WARNING]:
                risk_level = SeverityLevel.WARNING
            reasons.append(f"Обнаружены паттерны в нескольких категориях ({results['basic_info']['total_categories']})")
            recommendations.append("Проверить все подозрительные категории")
        
        # Специальные проверки для критических категорий
        critical_categories = ["anti_debug", "shell", "process"]
        for category in critical_categories:
            if category in results["pattern_analysis"]["categories"]:
                if self.risk_levels[risk_level] < self.risk_levels[SeverityLevel.WARNING]:
                    risk_level = SeverityLevel.WARNING
                reasons.append(f"Обнаружены паттерны категории {category}")
                recommendations.append(f"Проверить паттерны категории {category}")
        
        results["risk_assessment"].update({
            "level": risk_level,
            "reasons": reasons,
            "recommendations": recommendations
        })
    
    def _search_pattern(self, data: bytes, pattern: str) -> bool:
        """Поиск паттерна в данных"""
        try:
            return bool(re.search(pattern.encode(), data, re.IGNORECASE))
        except:
            return False
    
    def _get_pattern_description(self, category: str, pattern: str) -> str:
        """Возвращает описание паттерна"""
        descriptions = {
            "anti_debug": {
                "ptrace": "Обнаружение отладчика",
                "sysctl": "Проверка системных параметров",
                "task_for_pid": "Получение информации о процессе",
                "isatty": "Проверка терминала",
                "ioctl": "Управление устройством",
                "getppid": "Получение ID родительского процесса",
                "fork": "Создание дочернего процесса",
                "waitpid": "Ожидание завершения процесса"
            },
            "network": {
                "socket": "Создание сетевого сокета",
                "connect": "Подключение к удаленному хосту",
                "bind": "Привязка сокета",
                "listen": "Прослушивание соединений",
                "accept": "Принятие соединения",
                "send": "Отправка данных",
                "recv": "Получение данных",
                "inet_addr": "Преобразование IP-адреса",
                "gethostbyname": "Получение IP по имени хоста"
            },
            "file_ops": {
                "open": "Открытие файла",
                "write": "Запись в файл",
                "read": "Чтение файла",
                "unlink": "Удаление файла",
                "rename": "Переименование файла",
                "chmod": "Изменение прав доступа",
                "chown": "Изменение владельца",
                "mkdir": "Создание директории",
                "rmdir": "Удаление директории"
            },
            "process": {
                "exec": "Запуск программы",
                "system": "Выполнение команды",
                "popen": "Открытие процесса",
                "vfork": "Создание процесса",
                "kill": "Завершение процесса",
                "signal": "Установка обработчика сигнала",
                "setuid": "Установка UID",
                "setgid": "Установка GID"
            },
            "crypto": {
                "crypto": "Криптографические операции",
                "openssl": "Использование OpenSSL",
                "aes": "Шифрование AES",
                "des": "Шифрование DES",
                "rc4": "Шифрование RC4",
                "md5": "Хеширование MD5",
                "sha1": "Хеширование SHA1",
                "sha256": "Хеширование SHA256"
            },
            "shell": {
                "/bin/sh": "Использование shell",
                "/bin/bash": "Использование bash",
                "cmd": "Командная строка",
                "shell": "Оболочка",
                "sh -c": "Выполнение shell-команды",
                "bash -c": "Выполнение bash-команды"
            }
        }
        return descriptions.get(category, {}).get(pattern, "Неизвестный паттерн")

    def _print_patterns_info(self, info: Dict[str, Any]) -> None:
        """Выводит информацию о подозрительных паттернах"""
        try:
            # Основная информация
            basic_info = info["basic_info"]
            console.print("\n[bold magenta]Основная информация о подозрительных паттернах[/bold magenta]")
            basic_table = Table(show_header=True, header_style="bold magenta")
            basic_table.add_column("Параметр", style="cyan")
            basic_table.add_column("Значение", style="yellow")
            
            basic_rows = [
                ["Всего паттернов", str(basic_info["total_patterns"])],
                ["Категорий", str(basic_info["total_categories"])],
                ["Уровень риска", str(info["risk_assessment"]["level"])]
            ]
            
            for row in basic_rows:
                basic_table.add_row(*row)
            console.print(basic_table)
            
            # Паттерны по категориям
            if info["pattern_analysis"]["categories"]:
                console.print("\n[bold cyan]Подозрительные паттерны[/bold cyan]")
                for category, patterns in info["pattern_analysis"]["categories"].items():
                    console.print(f"\n[bold yellow]{category}[/bold yellow]")
                    pattern_table = Table(show_header=True, header_style="bold yellow")
                    pattern_table.add_column("Паттерн", style="cyan")
                    pattern_table.add_column("Описание", style="yellow")
                    
                    for pattern in patterns:
                        pattern_table.add_row(
                            pattern["pattern"],
                            pattern["description"]
                        )
                    console.print(pattern_table)
            
            # Локации паттернов
            if info["pattern_analysis"]["locations"]:
                console.print("\n[bold blue]Локации паттернов[/bold blue]")
                location_table = Table(show_header=True, header_style="bold blue")
                location_table.add_column("Сегмент", style="cyan")
                location_table.add_column("Смещение", style="yellow")
                location_table.add_column("Размер", style="green")
                location_table.add_column("Категория", style="magenta")
                
                for location in info["pattern_analysis"]["locations"]:
                    location_table.add_row(
                        location["segment"],
                        location["offset"],
                        str(location["size"]),
                        location["category"]
                    )
                console.print(location_table)
            
            # Оценка рисков
            if info["risk_assessment"]["reasons"]:
                console.print("\n[bold red]Оценка рисков[/bold red]")
                risk_table = Table(show_header=True, header_style="bold red")
                risk_table.add_column("Уровень", style="cyan")
                risk_table.add_column("Причины", style="yellow")
                risk_table.add_column("Рекомендации", style="green")
                
                risk_table.add_row(
                    str(info["risk_assessment"]["level"]),
                    "\n".join(info["risk_assessment"]["reasons"]),
                    "\n".join(info["risk_assessment"]["recommendations"])
                )
                console.print(risk_table)
                
        except Exception as e:
            console.print(f"[red]Ошибка при выводе информации о паттернах: {str(e)}[/red]")
    
    @staticmethod
    def get_name() -> str:
        return "malware_patterns"
    
    @staticmethod
    def get_description() -> str:
        return "Анализирует Mach-O файл на наличие подозрительных паттернов, связанных с вредоносным ПО"
    
    @staticmethod
    def get_version() -> str:
        return "1.0.0"
    
    @staticmethod
    def is_compatible() -> bool:
        return True 