# Анализ Mach-O файлов (MacOS X). 
### Финальный проект по курсе Reverse Engineering 
### Автор: Олег Дурандин (oleg.durandin@gmail.com)

## Постановка задачи
Разработать анализатор Mach-O файлов, с акцентом на Reverse-Engineer'ов и вирусных аналитиков.


Основные функции:
1. Базовый анализ заголовков
2. Просмотр секций и сегментов
3. Анализ импортов/экспортов
4. Детектирование встроенных данных
5. Поиск известных паттернов (anti-debugging, канарейки и т.д.)
6. Проверка механизмов безопасности
7. Проверка отладочной информации
8. Анализ обфускации
9. Анализ персистентности
10. Анализ сетевой активности
11. Анализ вредоносного ПО

## Структура проекта и общее описание

Проект имеет следующую структуру:

```tree
MachO-Analyzer/
├── src/        
│   ├── plugins/           # Плагины анализатора
│   │   ├── header_analyzer_plugin.py
│   │   ├── security_analyzer_plugin.py
│   │   ├── vulnerability_analyzer_plugin.py
│   │   ├── symbol_analyzer_plugin.py
│   │   ├── network_analyzer_plugin.py
│   │   ├── embedded_data_analyzer_plugin.py
│   │   ├── sign_analyzer_plugin.py
│   │   ├── permission_analyzer_plugin.py
│   │   ├── debug_analyzer_plugin.py
│   │   ├── obfuscation_analyzer_plugin.py
│   │   ├── persistence_analyzer_plugin.py
│   │   ├── malware_analyzer_plugin.py
│   │   └── malware_patterns_plugin.py            # Исходный код проекта
│   ├── core/              # Основные компоненты анализатора
│   │   ├── __init__.py
│   │   ├── header_analyzer.py    # Анализ заголовков Mach-O
│   │   ├── security_analyzer.py  # Анализ механизмов безопасности
│   │   ├── symbol_analyzer.py    # Анализ символов и импортов
│   │   ├── sign_analyzer.py      # Анализ подписей кода
│   │   ├── debug_analyzer.py     # Анализ отладочной информации
│   │   └── constants.py          # Константы и определения
|   |   └── plugin_base.py 
|   |   └── plugin_manager.py 
│   ├── utils/             # Вспомогательные утилиты
│   └── main.py            # Точка входа в программу
├── tests/                 # Тесты
├── requirements.txt       # Зависимости проекта
└── README.md             # Документация проекта
```

## Основные компоненты

Изначально структура проекта включала комплект анализаторов, в составе Mach-O Analyzer, однако, на основании обратной связи куратора архитектура была переработана с акцентом на расширяемость и добавление нового функционала посредством плагинов (plugins).

### 1. Плагины анализатора (src/plugins/)

#### header_analyzer_plugin.py
- Анализ заголовков Mach-O файлов
- Тип CPU и архитектура
- Флаги файла
- Сегменты и секции
- Версии и идентификаторы

#### security_analyzer_plugin.py
- Проверка механизмов безопасности
- ASLR (Address Space Layout Randomization)
- NX (Non-Executable Stack)
- Stack Canary
- RELRO (RELocation Read-Only)
- Safe Stack
- FORTIFY_SOURCE
- Подпись кода
- Анти-отладочные техники

#### vulnerability_analyzer_plugin.py
- Анализ уязвимых функций
- Проверка переполнения буфера
- Анализ строковых функций
- Проверка форматирования строк
- Анализ управления памятью

#### symbol_analyzer_plugin.py
- Анализ символов и импортов
- Глобальные символы
- Динамические библиотеки
- Импортируемые функции
- Экспортируемые символы

#### network_analyzer_plugin.py
- Анализ сетевой активности
- Сетевые функции
- HTTP/HTTPS операции
- DNS операции
- Сетевые протоколы

#### embedded_data_analyzer_plugin.py
- Анализ встроенных данных
- Строковые литералы
- Криптографические константы
- Чувствительные данные
- Ресурсы

#### sign_analyzer_plugin.py
- Анализ подписей кода
- Статус подписи
- Тип подписи
- Team ID
- Timestamp

#### permission_analyzer_plugin.py
- Анализ разрешений
- Права доступа
- Привилегии
- Ограничения
- Entitlements

#### debug_analyzer_plugin.py
- Анализ отладочной информации
- DWARF информация
- Отладочные символы
- UUID dSYM
- Отладочные маркеры

#### obfuscation_analyzer_plugin.py
- Анализ обфускации
- Методы обфускации
- Сложность анализа
- Уровень защиты
- Паттерны обфускации

#### persistence_analyzer_plugin.py
- Анализ персистентности
- Механизмы сохранения
- Автозапуск
- Регистрация
- Планировщик задач

#### malware_analyzer_plugin.py
- Анализ вредоносного ПО
- Известные паттерны
- Подозрительные функции
- Вредоносное поведение
- Классификация



### 2. Main (src/main.py)
- Точка входа в программу
- Обработка аргументов командной строки
- Координация работы анализаторов
- Форматирование результатов

## Технические детали

### Используемые библиотеки
- `macholib`: Основная библиотека для работы с Mach-O форматом
- `rich`: Форматирование вывода
- `dataclasses`: Для создания классов данных
- `enum`: Для определения перечислений
- `typing`: Для аннотаций типов


Этот анализ позволяет получить полную картину структуры Mach-O файла и его характеристик безопасности, что является важным этапом в процессе анализа безопасности приложения.

## Тестирование
- Модульные тесты для каждого плагина
- Тесты на различные типы файлов
- Проверка обработки ошибок


## Документация
- README.md содержит общее описание проекта
- Комментарии в коде объясняют сложные алгоритмы

## Требования к системе
- Python 3.6+
- macOS (для работы с Mach-O файлами)
- Установленные зависимости из requirements.txt

## Ограничения и известные проблемы
- Не все форматы Mach-O поддерживаются
- Некоторые проверки могут быть неточными
- Требуется доступ к исходному коду
- Ограничения на некоторые архитектуры

## Планы по улучшению
- Добавление новых проверок
- Улучшение точности анализа
- Расширение поддержки форматов
- Оптимизация производительности


В ходе дальнейшего изложения будут описаны ключевые пункты, касающиеся Mach-O файлов, их анализу в представленном анализаторе и вспомогательная информация, необходимая для понимания.

# Mach-O файлы
Mach-O (Mach Object) - это формат исполняемых файлов, используемый в ОС macOS и iOS. Этот формат был разработан для поддержки различных архитектур процессоров (x86_64, ARM64) и предоставляет гибкую структуру для хранения исполняемого кода, данных и метаданных.

## Структура Mach-O файла

Mach-O файл состоит из следующих основных компонентов:
1. Заголовок (Header)
* Содержит основную информацию о файле
* Определяет архитектуру и тип файла
* Указывает на расположение команд загрузки
2. Команды загрузки (Load Commands)
* Описывают как и где загружать различные части файла
* Определяют права доступа к сегментам
* Указывают на зависимости и символы
3. Данные (Data)
* Содержит исполняемый код
* Хранит данные программы
* Включает таблицы символов и строк

## Заголовок Mach-O файла
Заголовок Mach-O файла (Mach header) является первой структурой в файле и содержит основную информацию о формате и содержимом файла. Существует два варианта заголовка:

### Mach Header (32-bit)
Структура заголовка для 32-битных файлов содержит следующие поля:

```c
struct mach_header {
   uint32_t magic;
   cpu_type_t cputype;
   cpu_subtype_t cpusubtype;
   uint32_t filetype;
   uint32_t ncmds;
   uint32_t sizeofcmds;
   uint32_t flags;
};
```

- ``magic`` (uint32_t): Магическое число, идентифицирующее файл как Mach-O (``0xFEEDFACE``)
- ``cputype`` (cpu_type_t): Тип процессора (например, x86, ARM)
- ``cpusubtype`` (cpu_subtype_t): Подтип процессора
- ``filetype`` (uint32_t): Тип файла (исполняемый, библиотека и т.д.)
- ``ncmds`` (uint32_t): Количество команд загрузки
- ``sizeofcmds`` (uint32_t): Общий размер всех команд загрузки
- ``flags`` (uint32_t): Флаги, определяющие различные характеристики файла

### Mach Header 64 (64-bit)
Для 64-битных файлов структура расширена и включает дополнительное поле:


```c
struct mach_header_64 {
   uint32_t magic;
   cpu_type_t cputype;
   cpu_subtype_t cpusubtype;
   uint32_t filetype;
   uint32_t ncmds;
   uint32_t sizeofcmds;
   uint32_t flags;
   uint32_t reserved;
};
```

- ``magic`` (uint32_t): Магическое число для 64-bit (0xFEEDFACF)
- ``cputype`` (cpu_type_t): Тип процессора
- ``cpusubtype`` (cpu_subtype_t): Подтип процессора  
- ``filetype`` (uint32_t): Тип файла
- ``ncmds`` (uint32_t): Количество команд загрузки
- ``sizeofcmds`` (uint32_t): Общий размер команд
- ``flags`` (uint32_t): Флаги файла
- ``reserved`` (uint32_t): Зарезервированное поле (добавлено для 64-bit)


Полная спецификация, относительно ABI формата Mach-O файла в OS X может бы ть найдена по ссылке:
Link: https://github.com/aidansteele/osx-abi-macho-file-format-reference 


### Запуск анализатора

#### 1. Базовый анализ
```bash
python3 src/main.py /path/to/binary
```

#### 2. Анализ с выводом в файл
```bash
python3 src/main.py /path/to/binary > report.txt 
```

В выходном файле (см. примеры вывода в директории results) выводится информация в следующем порядке:

1. Заголовок и основная информация о сегментах (результат работы плагина ``header_analyzer_plugin.py`` )
2. Информация о механизмах безопасности, обнаруженных в Mach-O файле (результат работы плагина ``security_analyzer_plugin.py``)
3. Информация о потенциальных уязвимостях (``vulnerability_analyzer_plugin.py``)
4. Информация о символах и импортах (``symbol_analyzer_plugin.py``)
5. Информация функциях, связанных с сетевой активности (``network_analyzer_plugin.py``)
6. Анализатор данных, встроенных в бинарный файл, и представляющих потенциальный интерес для реверс-инженера (``embedded_data_analyzer_plugin.py``)
7. Анализатор подписей (механизм в OS X) - ``sign_analyzer_plugin.py``
8. Анализатор разрешений, запрашиваемых файлом - ``permission_analyzer_plugin.py``
9. Анализатор отладочной информации ``debug_analyzer_plugin.py``
10. Анализвтор обфускации файла ``obfuscation_analyzer_plugin.py``
11. Анализ механизмов персистентности ``persistence_analyzer_plugin.py``

Все плагины располагаются в папке ``/src/plugins/*_plugin.py`` и имеют интерфейс, реализующий абстрактный класс ``/src/core/plugin_base.py``.

Далее, описаны каждый из плагинов с сопутствующим функционалом.

## Плагины для Mach-O Analyzer
Механизм плагинов имлементирован для боле легкой расширяемости приложения.
Таким образом, посредством плагинов каждый пользователь может добавить требуемый ему функционал.

### Абстрактный класс MachOPlugin 
Расположен в ``/src/core/plugin_base.py``


```python
class MachOPlugin(ABC):
    """Базовый класс для всех плагинов анализатора Mach-O"""
    
    def __init__(self, macho: MachO, file_path: str):
        self.macho = macho
        self.file_path = file_path
    
    @abstractmethod
    def analyze(self) -> Dict[str, Any]:
        """Основной метод анализа. Должен возвращать словарь с результатами"""
        pass
    
    @staticmethod
    @abstractmethod
    def get_name() -> str:
        """Возвращает имя плагина"""
        pass
    
    @staticmethod
    @abstractmethod
    def get_description() -> str:
        """Возвращает описание функционала плагина"""
        pass
    
    @staticmethod
    @abstractmethod
    def get_version() -> str:
        """Возвращает версию плагина"""
        pass
    
    def get_dependencies(self) -> List[str]:
        """Возвращает список зависимостей плагина"""
        return []
    
    def is_compatible(self) -> bool:
        """Проверяет совместимость плагина с текущим файлом"""
        return True 
```

Каждый плагин должен отнаследоваться от базового класса и имплементировать абстрактные методы.
