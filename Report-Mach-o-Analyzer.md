# Анализ Mach-O файлов (MacOS X). 
### Финальный проект по курсе Reverse Engineering 
### Автор: Олег Дурандин (oleg.durandin@gmail.com)

## Постановка задачи
Разработать анализатор Mach-O файлов, с акцентом на Reverse-Engineer'ов и вирусных аналитиков.


Основные функции:
1. Базовый анализ заголовков
2. Просмотр секций и сегментов
3. Анализ импортов/экспортов
4. Детектирование встроенных данных
5. Поиск известных паттернов (anti-debugging, канарейки и т.д.)
6. Проверка механизмов безопасности
7. Проверка отладочной информации
8. Анализ обфускации
9. Анализ персистентности
10. Анализ сетевой активности
11. Анализ вредоносного ПО

## Структура проекта и общее описание

Проект имеет следующую структуру:

```tree
MachO-Analyzer/
├── src/        
│   ├── plugins/           # Плагины анализатора
│   │   ├── header_analyzer_plugin.py
│   │   ├── security_analyzer_plugin.py
│   │   ├── vulnerability_analyzer_plugin.py
│   │   ├── symbol_analyzer_plugin.py
│   │   ├── network_analyzer_plugin.py
│   │   ├── embedded_data_analyzer_plugin.py
│   │   ├── sign_analyzer_plugin.py
│   │   ├── permission_analyzer_plugin.py
│   │   ├── debug_analyzer_plugin.py
│   │   ├── obfuscation_analyzer_plugin.py
│   │   ├── persistence_analyzer_plugin.py
│   │   ├── malware_analyzer_plugin.py
│   │   └── malware_patterns_plugin.py            # Исходный код проекта
│   ├── core/              # Основные компоненты анализатора
│   │   ├── __init__.py
│   │   ├── header_analyzer.py    # Анализ заголовков Mach-O
│   │   ├── security_analyzer.py  # Анализ механизмов безопасности
│   │   ├── symbol_analyzer.py    # Анализ символов и импортов
│   │   ├── sign_analyzer.py      # Анализ подписей кода
│   │   ├── debug_analyzer.py     # Анализ отладочной информации
│   │   └── constants.py          # Константы и определения
|   |   └── plugin_base.py 
|   |   └── plugin_manager.py 
│   ├── utils/             # Вспомогательные утилиты
│   └── main.py            # Точка входа в программу
├── tests/                 # Тесты
├── requirements.txt       # Зависимости проекта
└── README.md             # Документация проекта
```

## Основные компоненты

Изначально структура проекта включала комплект анализаторов, в составе Mach-O Analyzer, однако, на основании обратной связи куратора архитектура была переработана с акцентом на расширяемость и добавление нового функционала посредством плагинов (plugins).

### 1. Плагины анализатора (src/plugins/)

#### header_analyzer_plugin.py
- Анализ заголовков Mach-O файлов
- Тип CPU и архитектура
- Флаги файла
- Сегменты и секции
- Версии и идентификаторы

#### security_analyzer_plugin.py
- Проверка механизмов безопасности
- ASLR (Address Space Layout Randomization)
- NX (Non-Executable Stack)
- Stack Canary
- RELRO (RELocation Read-Only)
- Safe Stack
- FORTIFY_SOURCE
- Подпись кода
- Анти-отладочные техники

#### vulnerability_analyzer_plugin.py
- Анализ уязвимых функций
- Проверка переполнения буфера
- Анализ строковых функций
- Проверка форматирования строк
- Анализ управления памятью

#### symbol_analyzer_plugin.py
- Анализ символов и импортов
- Глобальные символы
- Динамические библиотеки
- Импортируемые функции
- Экспортируемые символы

#### network_analyzer_plugin.py
- Анализ сетевой активности
- Сетевые функции
- HTTP/HTTPS операции
- DNS операции
- Сетевые протоколы

#### embedded_data_analyzer_plugin.py
- Анализ встроенных данных
- Строковые литералы
- Криптографические константы
- Чувствительные данные
- Ресурсы

#### sign_analyzer_plugin.py
- Анализ подписей кода
- Статус подписи
- Тип подписи
- Team ID
- Timestamp

#### permission_analyzer_plugin.py
- Анализ разрешений
- Права доступа
- Привилегии
- Ограничения
- Entitlements

#### debug_analyzer_plugin.py
- Анализ отладочной информации
- DWARF информация
- Отладочные символы
- UUID dSYM
- Отладочные маркеры

#### obfuscation_analyzer_plugin.py
- Анализ обфускации
- Методы обфускации
- Сложность анализа
- Уровень защиты
- Паттерны обфускации

#### persistence_analyzer_plugin.py
- Анализ персистентности
- Механизмы сохранения
- Автозапуск
- Регистрация
- Планировщик задач

#### malware_analyzer_plugin.py
- Анализ вредоносного ПО
- Известные паттерны
- Подозрительные функции
- Вредоносное поведение
- Классификация



### 2. Main (src/main.py)
- Точка входа в программу
- Обработка аргументов командной строки
- Координация работы анализаторов
- Форматирование результатов

## Технические детали

### Используемые библиотеки
- `macholib`: Основная библиотека для работы с Mach-O форматом
- `rich`: Форматирование вывода
- `dataclasses`: Для создания классов данных
- `enum`: Для определения перечислений
- `typing`: Для аннотаций типов


Этот анализ позволяет получить полную картину структуры Mach-O файла и его характеристик безопасности, что является важным этапом в процессе анализа безопасности приложения.

## Тестирование
- Модульные тесты для каждого плагина
- Тесты на различные типы файлов
- Проверка обработки ошибок


## Документация
- README.md содержит общее описание проекта
- Комментарии в коде объясняют сложные алгоритмы

## Требования к системе
- Python 3.6+
- macOS (для работы с Mach-O файлами)
- Установленные зависимости из requirements.txt

## Ограничения и известные проблемы
- Не все форматы Mach-O поддерживаются
- Некоторые проверки могут быть неточными
- Требуется доступ к исходному коду
- Ограничения на некоторые архитектуры

## Планы по улучшению
- Добавление новых проверок
- Улучшение точности анализа
- Расширение поддержки форматов
- Оптимизация производительности


В ходе дальнейшего изложения будут описаны ключевые пункты, касающиеся Mach-O файлов, их анализу в представленном анализаторе и вспомогательная информация, необходимая для понимания.

# Mach-O файлы
Mach-O (Mach Object) - это формат исполняемых файлов, используемый в ОС macOS и iOS. Этот формат был разработан для поддержки различных архитектур процессоров (x86_64, ARM64) и предоставляет гибкую структуру для хранения исполняемого кода, данных и метаданных.

## Структура Mach-O файла

Mach-O файл состоит из следующих основных компонентов:
1. Заголовок (Header)
* Содержит основную информацию о файле
* Определяет архитектуру и тип файла
* Указывает на расположение команд загрузки
2. Команды загрузки (Load Commands)
* Описывают как и где загружать различные части файла
* Определяют права доступа к сегментам
* Указывают на зависимости и символы
3. Данные (Data)
* Содержит исполняемый код
* Хранит данные программы
* Включает таблицы символов и строк

## Заголовок Mach-O файла
Заголовок Mach-O файла (Mach header) является первой структурой в файле и содержит основную информацию о формате и содержимом файла. Существует два варианта заголовка:

### Mach Header (32-bit)
Структура заголовка для 32-битных файлов содержит следующие поля:

```c
struct mach_header {
   uint32_t magic;
   cpu_type_t cputype;
   cpu_subtype_t cpusubtype;
   uint32_t filetype;
   uint32_t ncmds;
   uint32_t sizeofcmds;
   uint32_t flags;
};
```

- ``magic`` (uint32_t): Магическое число, идентифицирующее файл как Mach-O (``0xFEEDFACE``)
- ``cputype`` (cpu_type_t): Тип процессора (например, x86, ARM)
- ``cpusubtype`` (cpu_subtype_t): Подтип процессора
- ``filetype`` (uint32_t): Тип файла (исполняемый, библиотека и т.д.)
- ``ncmds`` (uint32_t): Количество команд загрузки
- ``sizeofcmds`` (uint32_t): Общий размер всех команд загрузки
- ``flags`` (uint32_t): Флаги, определяющие различные характеристики файла

### Mach Header 64 (64-bit)
Для 64-битных файлов структура расширена и включает дополнительное поле:


```c
struct mach_header_64 {
   uint32_t magic;
   cpu_type_t cputype;
   cpu_subtype_t cpusubtype;
   uint32_t filetype;
   uint32_t ncmds;
   uint32_t sizeofcmds;
   uint32_t flags;
   uint32_t reserved;
};
```

- ``magic`` (uint32_t): Магическое число для 64-bit (0xFEEDFACF)
- ``cputype`` (cpu_type_t): Тип процессора
- ``cpusubtype`` (cpu_subtype_t): Подтип процессора  
- ``filetype`` (uint32_t): Тип файла
- ``ncmds`` (uint32_t): Количество команд загрузки
- ``sizeofcmds`` (uint32_t): Общий размер команд
- ``flags`` (uint32_t): Флаги файла
- ``reserved`` (uint32_t): Зарезервированное поле (добавлено для 64-bit)


Полная спецификация, относительно ABI формата Mach-O файла в OS X может бы ть найдена по ссылке:
Link: https://github.com/aidansteele/osx-abi-macho-file-format-reference 


### Запуск анализатора

#### 1. Базовый анализ
```bash
python3 src/main.py /path/to/binary
```

#### 2. Анализ с выводом в файл
```bash
python3 src/main.py /path/to/binary > report.txt 
```

В выходном файле (см. примеры вывода в директории results) выводится информация в следующем порядке:

1. Заголовок и основная информация о сегментах (результат работы плагина ``header_analyzer_plugin.py`` )
2. Информация о механизмах безопасности, обнаруженных в Mach-O файле (результат работы плагина ``security_analyzer_plugin.py``)
3. Информация о потенциальных уязвимостях (``vulnerability_analyzer_plugin.py``)
4. Информация о символах и импортах (``symbol_analyzer_plugin.py``)
5. Информация функциях, связанных с сетевой активности (``network_analyzer_plugin.py``)
6. Анализатор данных, встроенных в бинарный файл, и представляющих потенциальный интерес для реверс-инженера (``embedded_data_analyzer_plugin.py``)
7. Анализатор подписей (механизм в OS X) - ``sign_analyzer_plugin.py``
8. Анализатор разрешений, запрашиваемых файлом - ``permission_analyzer_plugin.py``
9. Анализатор отладочной информации ``debug_analyzer_plugin.py``
10. Анализвтор обфускации файла ``obfuscation_analyzer_plugin.py``
11. Анализ механизмов персистентности ``persistence_analyzer_plugin.py``

Все плагины располагаются в папке ``/src/plugins/*_plugin.py`` и имеют интерфейс, реализующий абстрактный класс ``/src/core/plugin_base.py``.

Далее, описаны каждый из плагинов с сопутствующим функционалом.

## Плагины для Mach-O Analyzer
Механизм плагинов имлементирован для боле легкой расширяемости приложения.
Таким образом, посредством плагинов каждый пользователь может добавить требуемый ему функционал.

### Абстрактный класс MachOPlugin 
Расположен в ``/src/core/plugin_base.py``


```python
class MachOPlugin(ABC):
    """Базовый класс для всех плагинов анализатора Mach-O"""
    
    def __init__(self, macho: MachO, file_path: str):
        self.macho = macho
        self.file_path = file_path
    
    @abstractmethod
    def analyze(self) -> Dict[str, Any]:
        """Основной метод анализа. Должен возвращать словарь с результатами"""
        pass
    
    @staticmethod
    @abstractmethod
    def get_name() -> str:
        """Возвращает имя плагина"""
        pass
    
    @staticmethod
    @abstractmethod
    def get_description() -> str:
        """Возвращает описание функционала плагина"""
        pass
    
    @staticmethod
    @abstractmethod
    def get_version() -> str:
        """Возвращает версию плагина"""
        pass
    
    def get_dependencies(self) -> List[str]:
        """Возвращает список зависимостей плагина"""
        return []
    
    def is_compatible(self) -> bool:
        """Проверяет совместимость плагина с текущим файлом"""
        return True 
```

Каждый плагин должен отнаследоваться от базового класса и имплементировать абстрактные методы.


### Плагин анализа заголовка ``header_analyzer_plugin.py``

Анализатор заголовков является ключевым компонентом Mach-O Analyzer, который предоставляет детальную информацию о структуре и характеристиках Mach-O файла. Этот анализатор необходим для понимания базовой архитектуры файла и его совместимости с целевой системой.

#### Основной функционал ``header_analyzer_plugin.py``

1. **Анализ базовой информации**
   - Magic number (идентификатор формата файла)
   - Битность (32/64-bit)
   - Тип CPU и подтип
   - Тип файла (исполняемый, библиотека и т.д.)
   - Количество и размер команд загрузки
   - Размер файла
   - Дата модификации

2. **Анализ версий и идентификаторов**

В Mach-O файлах хранится важная информация о версиях и идентификаторах, которая помогает отслеживать совместимость и отладку:

   - UUID файла (уникальный идентификатор)
      - Используется для свзяывания исполняемого файла с его отладочными символами (dSYM) - например, отладчики используют UUID для корректной привязки отладочных символов к исполняемому файлу 
      - При динамическом анализе UUID позволяет идентифицировать версию бинарного файла
      - В FAT файлах каждая архитектура имеет свой уникальный UUID
   - Минимальная версия OS
      - Формат: `MAJOR.MINOR.PATCH` (Пример: `10.13.0`)
      - Показывает минимальную версию macOS, требуемую для запуска файла
      - Важно для:
         - Определения совместимости с целевой системой
         - Проверки доступности API и функций
         - Отладки проблем, связанных с версиями ОС
         - Планирования поддержки старых версий
   - Версия SDK
      - Формат: `MAJOR.MINOR.PATCH`
      - Указывает версию SDK, использованного при компиляции
      - Полезно для:
         - Отслеживания используемых API и функций
         - Определения доступных возможностей
         - Проверки совместимости с целевой системой
         - Отладки проблем, связанных с SDK
   - Версия исходного кода
      - Формат: `MAJOR.MINOR.PATCH.BUILD` (Пример: `7619.1.26.31.7`)
      - Показывает версию исходного кода, из которого был собран файл
      - Полезно для:
         - Отслеживания изменений в коде
         - Определения совместимости версий
         - Связывания с конкретными коммитами в системе контроля версий
         - Отладки проблем, связанных с конкретными версиями кода
   - Версия сборки
      - Формат: `MAJOR.MINOR`
      - Указывает версию операционной системы, для которой была создана сборка
      - Важно для:
         - Определения минимальной версии macOS, требуемой для запуска
         - Проверки совместимости с целевой системой
         - Отладки проблем, связанных с версиями ОС
         - Планирования обновлений и поддержки


3. **Анализ флагов**
   - ``MH_NOUNDEFS`` (отсутствие неопределенных символов)
   - ``MH_DYLDLINK`` (динамическая линковка)
      - Загрузка библиотек во время выполнения, что уменьшает размер файла
   - ``MH_TWOLEVEL`` (двухуровневое пространство имен)
      - Предотвращает кофнликт имен и обеспечивает изоляцию между модулями
   - ``MH_PIE`` (Position Independent Executable)
      - Включена поддержка ASLR
      - Усложняет атаки на переполнение буфера
   - ``MH_NO_HEAP_EXECUTION`` (запрет выполнения в куче)
      - Улучшает защиту от heap-spray атак
      - Предотвращает выполнение shellcode в куче
   - ``MH_ALLOW_STACK_EXECUTION`` 
      - Разрешение выполнения кода в стеке
      - Потенциально опасный флаг (рекомендуется отключить для безопасности)
   - ``MH_ROOT_SAFE`` (Безопасность при запуске от root)
      - Ограничение привелегий
      - Обеспечивает защиту от повышения привилегий

4. **Анализ сегментов**
   - Имя сегмента
   - Виртуальный адрес (``VMAddr``)
   - Размер в памяти (``VMSize``)
   - Смещение в файле (`FileOff`)
   - Размер в файле (`FileSize`)
   - Права доступа (`maxprot`, `initprot`)
   - Количество секций

Сегменты в Mach-O файле представляют собой логические разделы памяти, каждый со своими правами доступа и назначением. Для анализа вредоносного ПО особое внимание следует уделять следующим аспектам:

#### Основные сегменты и их анализ
- **`__TEXT`**
  - Содержит исполняемый код
  - Должен иметь права R-X (чтение и выполнение)
  - Подозрительные признаки:
    - Права RWX (чтение, запись, выполнение)
    - Необычно большой размер
    - Нестандартное смещение

- **`__DATA`**
  - Содержит инициализированные данные
  - Типичные права RW- (чтение и запись)
  - Подозрительные признаки:
    - Права на выполнение (X)
    - Необычно большой размер
    - Скрытые данные в неиспользуемых областях

- **`__BSS`**
  - Неинициализированные данные
  - Права RW- (чтение и запись)
  - Подозрительные признаки:
    - Необычно большой размер
    - Права на выполнение
    - Скрытые данные

- **`__LINKEDIT`**
  - Содержит информацию о линковке
  - Типичные права R-- (только чтение)
  - Подозрительные признаки:
    - Права на запись
    - Нестандартное содержимое
    - Скрытые строки или данные

#### Критические параметры для анализа
- **Виртуальный адрес (VMAddr)**
  - Начальный адрес сегмента в памяти
  - Подозрительные признаки:
    - Нестандартные адреса
    - Перекрытие с другими сегментами
    - Адреса в системных областях

- **Размер в памяти (VMSize)**
  - Размер сегмента при загрузке
  - Подозрительные признаки:
    - Несоответствие с FileSize
    - Необычно большой размер
    - Размер, не кратный странице памяти

- **Смещение в файле (FileOff)**
  - Позиция сегмента в файле
  - Подозрительные признаки:
    - Нестандартное выравнивание
    - Перекрытие с другими сегментами
    - Скрытые данные между сегментами

- **Размер в файле (FileSize)**
  - Размер сегмента в файле
  - Подозрительные признаки:
    - Несоответствие с VMSize
    - Необычно маленький размер
    - Размер, не кратный странице

- **Права доступа**
  - maxprot: максимальные права
  - initprot: начальные права
  - Подозрительные признаки:
    - Права RWX в любом сегменте
    - Нестандартные комбинации прав
    - Изменение прав во время выполнения



5. **Анализ секций**

Секции являются подразделениями сегментов и содержат конкретные типы данных. Плагин выделет следующие аспекты


   - Имя секции
   - Адрес
   - Размер
   - Флаги атрибутов:
     - PURE_INSTRUCTIONS (чистый код)
     - NO_TOC (отсутствие таблицы содержания)
     - STRIP_STATIC_SYMS (удаление статических символов)
     - NO_DEAD_STRIP (сохранение неиспользуемого кода)
     - LIVE_SUPPORT (поддержка живых символов)
     - SELF_MODIFYING_CODE (самомодифицирующийся код - потенциально опасный признак, усложняет статический анализ и возможна обфускация)
     - DEBUG (отладочная информация)
     - SOME_INSTRUCTIONS (смешанный код)
     - EXT_RELOC (внешние перемещения)
     - LOC_RELOC (локальные перемещения)


#### Применение

Анализатор заголовков используется для:

1. **Определения совместимости**
   - Проверка архитектуры (x86_64, arm64)
   - Проверка минимальной версии OS
   - Проверка типа файла

2. **Анализа безопасности**
   - Проверка флагов защиты (PIE, NX)
   - Анализ прав доступа к сегментам
   - Проверка механизмов безопасности

3. **Отладки и анализа**
   - Поиск отладочной информации
   - Анализ структуры памяти
   - Проверка символов и перемещений

4. **Оптимизации**
   - Анализ размера файла
   - Проверка неиспользуемого кода
   - Оптимизация загрузки

#### Рекомендации по безопасности

Анализатор предоставляет рекомендации по улучшению безопасности:

1. **Критические рекомендации**
   - Включение PIE для ASLR
   - Запрет выполнения в куче
   - Правильная настройка прав доступа

2. **Оптимизация**
   - Удаление неиспользуемого кода
   - Оптимизация размера файла
   - Улучшение производительности

3. **Совместимость**
   - Проверка версий OS
   - Поддержка архитектур
   - Корректная линковка

#### Вывод результатов 

Ниже приведен пример вывода для приложения [Telegram](https://telegram.org/)

```

Основная информация
┏━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Параметр          ┃ Значение                       ┃
┡━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ Magic             │ 0xfeedfacf (MH_MAGIC_64)       │
│ Битность          │ 64-bit                         │
│ CPU Type          │ x86_64                         │
│ CPU Subtype       │ All                            │
│ Тип файла         │ Executable                     │
│ Количество команд │ 109                            │
│ Размер команд     │ 12272                          │
│ Размер файла      │ 170789.28 Kb (174888224 bytes) │
│ Дата модификации  │ 2025-03-26 17:27:54            │
└───────────────────┴────────────────────────────────┘

Версии и идентификаторы
┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Параметр       ┃ Значение                         ┃
┡━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ Uuid           │ c4a3a9bbaa0d3f23a83b304db6375e48 │
│ Min Os Version │ 10.13.0                          │
│ Sdk Version    │ 14.0.0                           │
│ Source Version │ 0.0.0.0.0                        │
└────────────────┴──────────────────────────────────┘

Флаги
┏━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Флаг                   ┃ Описание                                  ┃
┡━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ MH_NOUNDEFS            │ Не содержит неопределенных символов       │
│ MH_DYLDLINK            │ Динамически связанный                     │
│ MH_TWOLEVEL            │ Двухуровневое пространство имен           │
│ MH_WEAK_DEFINES        │ Слабые определения                        │
│ MH_BINDS_TO_WEAK       │ Связывается со слабыми символами          │
│ MH_PIE                 │ Position Independent Executable           │
│ MH_HAS_TLV_DESCRIPTORS │ Содержит дескрипторы Thread Local Storage │
└────────────────────────┴───────────────────────────────────────────┘

Сегменты
┏━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┓
┃ Имя        ┃ VMAddr      ┃ VMSize      ┃ FileOff   ┃ FileSize  ┃ Защита            ┃ NSects ┃
┡━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━┩
│ __PAGEZERO │ 0x0         │ 0x100000000 │ 0x0       │ 0x0       │ max=---, init=--- │ 0      │
│ __TEXT     │ 0x100000000 │ 0x4d98000   │ 0x0       │ 0x4d98000 │ max=R-X, init=R-X │ 25     │
│ __DATA     │ 0x104d98000 │ 0x18d8000   │ 0x4d98000 │ 0x72c000  │ max=RW-, init=RW- │ 29     │
│ __LINKEDIT │ 0x106670000 │ 0x4a4000    │ 0x54c4000 │ 0x4a2bb0  │ max=R--, init=R-- │ 0      │
└────────────┴─────────────┴─────────────┴───────────┴───────────┴───────────────────┴────────┘

Секции в __TEXT
┏━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Имя              ┃ Адрес       ┃ Размер   ┃ Флаги                                ┃
┡━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ __text           │ 0x100007000 │ 73893769 │ PURE_INSTRUCTIONS, SOME_INSTRUCTIONS │
│ __stubs          │ 0x10467f78a │ 13908    │ PURE_INSTRUCTIONS, SOME_INSTRUCTIONS │
│ __stub_helper    │ 0x104682de0 │ 22696    │ PURE_INSTRUCTIONS, SOME_INSTRUCTIONS │
│ __const          │ 0x104688700 │ 2107592  │ -                                    │
│ __objc_methname  │ 0x10488afc8 │ 248304   │ -                                    │
│ __swift5_typeref │ 0x1048c79b8 │ 363955   │ -                                    │
│ __cstring        │ 0x104920770 │ 1890859  │ -                                    │
│ __constg_swiftt  │ 0x104aee19c │ 534696   │ -                                    │
│ __swift5_proto   │ 0x104b70a44 │ 34228    │ -                                    │
│ __swift5_types   │ 0x104b78ff8 │ 31548    │ -                                    │
│ __swift5_protos  │ 0x104b80b34 │ 704      │ -                                    │
│ __swift5_entry   │ 0x104b80df4 │ 8        │ -                                    │
│ __swift5_fieldmd │ 0x104b80dfc │ 294744   │ -                                    │
│ __swift5_builtin │ 0x104bc8d54 │ 12080    │ -                                    │
│ __swift5_reflstr │ 0x104bcbc90 │ 265102   │ -                                    │
│ __swift5_assocty │ 0x104c0c820 │ 20152    │ -                                    │
│ __swift5_capture │ 0x104c116d8 │ 266172   │ -                                    │
│ __swift5_mpenum  │ 0x104c52694 │ 16708    │ -                                    │
│ __gcc_except_tab │ 0x104c567d8 │ 341628   │ -                                    │
│ __objc_classname │ 0x104ca9e54 │ 18207    │ -                                    │
│ __objc_methtype  │ 0x104cae573 │ 82416    │ -                                    │
│ __ustring        │ 0x104cc2764 │ 3922     │ -                                    │
│ __ms_ios         │ 0x104cc36b6 │ 97       │ -                                    │
│ __unwind_info    │ 0x104cc3718 │ 654724   │ -                                    │
│ __eh_frame       │ 0x104d634a0 │ 212256   │ -                                    │
└──────────────────┴─────────────┴──────────┴──────────────────────────────────────┘

```

