# Анализ Mach-O файлов (MacOS X). 
### Финальный проект по курсе Reverse Engineering 
### Автор: Олег Дурандин (oleg.durandin@gmail.com)

## Постановка задачи
Разработать анализатор Mach-O файлов, с акцентом на Reverse-Engineer'ов и вирусных аналитиков.


Основные функции:
1) Базовый анализ заголовков
2) Просмотр секций и сегментов
3) Анализ импортов/экспортов
4) Детектирование встроенных данных
5) Поиск известных паттернов (например, anti-debugging техник, канареек и т.д.)
6) Проверка механизмов безопасности NX / DEP , ASLR, CFI (эвристика - выяснили, что неактуально для MacOS), safe stack, reloc entiries
7) Проверка осталась ли отладочная информация

## Структура проекта и общее описание

Проект имеет следующую структуру:

```tree
MachO-Analyzer/
├── src/                    # Исходный код проекта
│   ├── core/              # Основные компоненты анализатора
│   │   ├── __init__.py
│   │   ├── header_analyzer.py    # Анализ заголовков Mach-O
│   │   ├── security_analyzer.py  # Анализ механизмов безопасности
│   │   ├── symbol_analyzer.py    # Анализ символов и импортов
│   │   ├── sign_analyzer.py      # Анализ подписей кода
│   │   ├── debug_analyzer.py     # Анализ отладочной информации
│   │   └── constants.py          # Константы и определения
│   ├── utils/             # Вспомогательные утилиты
│   │   ├── __init__.py
│   │   └── helpers.py     # Общие функции-помощники
│   └── main.py            # Точка входа в программу
├── target_files/          # Тестовые файлы для анализа
│   └── test_app_with_fstack  # Тестовое приложение
├── tests/                 # Тесты
│   ├── __init__.py
│   └── test_security_analyzer.py
├── requirements.txt       # Зависимости проекта
└── README.md             # Документация проекта
```

## Основные компоненты

### 1. Core (src/core/)
- **header_analyzer.py**: Анализирует заголовки Mach-O файлов, включая:
  - Тип CPU
  - Флаги файла
  - Сегменты и секции
  - Версии и идентификаторы

- **security_analyzer.py**: Проверяет механизмы безопасности:
  - ASLR (Address Space Layout Randomization)
  - NX (Non-Executable Stack)
  - Stack Canary
  - RELRO (RELocation Read-Only)
  - Safe Stack
  - FORTIFY_SOURCE
  - Подпись кода
  - Анти-отладочные техники

- **symbol_analyzer.py**: Анализирует символы и импорты:
  - Глобальные символы
  - Динамические библиотеки
  - Импортируемые функции
  - Экспортируемые символы

- **sign_analyzer.py**: Проверяет подписи кода:
  - Статус подписи
  - Тип подписи
  - Team ID
  - Timestamp

- **debug_analyzer.py**: Анализирует отладочную информацию:
  - DWARF информация
  - Отладочные символы
  - UUID dSYM

### 2. Utils (src/utils/)
- **helpers.py**: Содержит вспомогательные функции для:
  - Работы с файлами
  - Форматирования вывода
  - Обработки ошибок

### 3. Main (src/main.py)
- Точка входа в программу
- Обработка аргументов командной строки
- Координация работы анализаторов
- Форматирование результатов

## Технические детали

### Используемые библиотеки
- `macholib`: Основная библиотека для работы с Mach-O форматом
- `dataclasses`: Для создания классов данных
- `enum`: Для определения перечислений
- `typing`: Для аннотаций типов

### Формат вывода
Результаты анализа выводятся в структурированном виде:

### Основная информация

| Параметр | Значение |
|----------|----------|
| Magic | MH_CIGAM_64 |
| Битность | 64-bit |
| CPU Type | arm64 |
| CPU Subtype | 0 |
| Тип файла | Executable |
| Количество команд | 17 |
| Размер команд | 1056 байт |

### Флаги

| Флаг | Описание |
|------|----------|
| MH_NOUNDEFS | Не содержит неопределенных символов |
| MH_DYLDLINK | Динамически связанный |
| MH_TWOLEVEL | Двухуровневое пространство имен |
| MH_PIE | Position Independent Executable |

### Особенности реализации:
1. Обработка ошибок:
* Проверка корректности магического числа
* Валидация типа CPU
* Обработка неизвестных флагов
2. Оптимизация:
* Кэширование результатов анализа
* Эффективное использование памяти
* Быстрый доступ к часто используемым значениям
3. Расширяемость:
* Легкое добавление новых флагов
* Поддержка новых типов CPU
* Возможность добавления дополнительных проверок

Этот анализ позволяет получить полную картину структуры Mach-O файла и его характеристик безопасности, что является важным этапом в процессе анализа безопасности приложения.

## Тестирование
Проект включает модульные тесты для проверки:
- Корректности анализа заголовков
- Работы механизмов безопасности
- Обработки различных типов файлов
- Форматирования вывода

## Документация
- README.md содержит общее описание проекта
- Комментарии в коде объясняют сложные алгоритмы

## Требования к системе
- Python 3.6+
- macOS (для работы с Mach-O файлами)
- Установленные зависимости из requirements.txt


В ходе дальнейшего изложения будут описаны ключевые пункты, касающиеся Mach-O файлов, их анализу в представленном анализаторе и вспомогательная информация, необходимая для понимания.

# Mach-O файлы
Mach-O (Mach Object) - это формат исполняемых файлов, используемый в ОС macOS и iOS. Этот формат был разработан для поддержки различных архитектур процессоров (x86_64, ARM64) и предоставляет гибкую структуру для хранения исполняемого кода, данных и метаданных.

## Структура Mach-O файла

Mach-O файл состоит из следующих основных компонентов:
1. Заголовок (Header)
* Содержит основную информацию о файле
* Определяет архитектуру и тип файла
* Указывает на расположение команд загрузки
2. Команды загрузки (Load Commands)
* Описывают как и где загружать различные части файла
* Определяют права доступа к сегментам
* Указывают на зависимости и символы
3. Данные (Data)
* Содержит исполняемый код
* Хранит данные программы
* Включает таблицы символов и строк

## Заголовок Mach-O файла
Заголовок Mach-O файла (Mach header) является первой структурой в файле и содержит основную информацию о формате и содержимом файла. Существует два варианта заголовка:

### Mach Header (32-bit)
Структура заголовка для 32-битных файлов содержит следующие поля:

```c
struct mach_header {
   uint32_t magic;
   cpu_type_t cputype;
   cpu_subtype_t cpusubtype;
   uint32_t filetype;
   uint32_t ncmds;
   uint32_t sizeofcmds;
   uint32_t flags;
};
```

- ``magic`` (uint32_t): Магическое число, идентифицирующее файл как Mach-O (``0xFEEDFACE``)
- ``cputype`` (cpu_type_t): Тип процессора (например, x86, ARM)
- ``cpusubtype`` (cpu_subtype_t): Подтип процессора
- ``filetype`` (uint32_t): Тип файла (исполняемый, библиотека и т.д.)
- ``ncmds`` (uint32_t): Количество команд загрузки
- ``sizeofcmds`` (uint32_t): Общий размер всех команд загрузки
- ``flags`` (uint32_t): Флаги, определяющие различные характеристики файла

### Mach Header 64 (64-bit)
Для 64-битных файлов структура расширена и включает дополнительное поле:


```c
struct mach_header_64 {
   uint32_t magic;
   cpu_type_t cputype;
   cpu_subtype_t cpusubtype;
   uint32_t filetype;
   uint32_t ncmds;
   uint32_t sizeofcmds;
   uint32_t flags;
   uint32_t reserved;
};
```

- ``magic`` (uint32_t): Магическое число для 64-bit (0xFEEDFACF)
- ``cputype`` (cpu_type_t): Тип процессора
- ``cpusubtype`` (cpu_subtype_t): Подтип процессора  
- ``filetype`` (uint32_t): Тип файла
- ``ncmds`` (uint32_t): Количество команд загрузки
- ``sizeofcmds`` (uint32_t): Общий размер команд
- ``flags`` (uint32_t): Флаги файла
- ``reserved`` (uint32_t): Зарезервированное поле (добавлено для 64-bit)


Link: https://github.com/aidansteele/osx-abi-macho-file-format-reference 

### Основные значения полей

#### Magic Numbers
- ``0xFEEDFACE`` - 32-битный Mach-O
- ``0xFEEDFACF`` - 64-битный Mach-O
- ``0xCAFEBABE`` - Universal binary

#### CPU Types
- ``CPU_TYPE_X86 (7)``
- ``CPU_TYPE_X86_64 (7 | CPU_ARCH_ABI64)``
- ``CPU_TYPE_ARM (12)``
- ``CPU_TYPE_ARM64 (12 | CPU_ARCH_ABI64)``

#### File Types
- ``MH_OBJECT (0x1)``: Объектный файл
- ``MH_EXECUTE (0x2)``: Исполняемый файл
- ``MH_DYLIB (0x6)``: Динамическая библиотека
- ``MH_BUNDLE (0x8)``: Bundle
- ``MH_DYLINKER (0x7)``: Динамический линковщик
- ``MH_DSYM (0xa)``: Отладочные символы

#### Flags
- ``MH_NOUNDEFS``: Нет неопределённых ссылок
- ``MH_DYLDLINK``: Объект является динамически связываемым
- ``MH_PIE``: Position Independent Executable
- ``MH_TWOLEVEL``: Двухуровневое пространство имён
- ``MH_WEAK_DEFINES``: Файл содержит слабо определённые символы
- ``MH_ALLOW_STACK_EXECUTION``: Разрешено исполнение стека

### Реализация анализа заголовка 

#### Класс HeaderAnalyzer


```python
class HeaderAnalyzer:
    def analyze(self, header: MachOHeader) -> Dict[str, Any]:
        """
        Анализирует заголовок Mach-O файла и возвращает структурированную информацию
        """
        result = {
            "magic": self._get_magic(header),
            "cpu_type": self._get_cpu_type(header),
            "file_type": self._get_file_type(header),
            "flags": self._get_flags(header),
            "commands": self._get_commands_info(header)
        }
        return result
```

Результаты анализа выводятся в структурированном виде:

### Основная информация

| Параметр | Значение |
|----------|----------|
| Magic | MH_CIGAM_64 |
| Битность | 64-bit |
| CPU Type | arm64 |
| CPU Subtype | 0 |
| Тип файла | Executable |
| Количество команд | 17 |
| Размер команд | 1056 байт |

### Флаги

| Флаг | Описание |
|------|----------|
| MH_NOUNDEFS | Не содержит неопределенных символов |
| MH_DYLDLINK | Динамически связанный |
| MH_TWOLEVEL | Двухуровневое пространство имен |
| MH_PIE | Position Independent Executable |

### Особенности реализации:
1. Обработка ошибок:
* Проверка корректности магического числа
* Валидация типа CPU
* Обработка неизвестных флагов
2. Оптимизация:
* Кэширование результатов анализа
* Эффективное использование памяти
* Быстрый доступ к часто используемым значениям
3. Расширяемость:
* Легкое добавление новых флагов
* Поддержка новых типов CPU
* Возможность добавления дополнительных проверок

Этот анализ позволяет получить полную картину структуры Mach-O файла и его характеристик безопасности, что является важным этапом в процессе анализа безопасности приложения.

### Версии и идентификаторы

В Mach-O файлах хранится важная информация о версиях и идентификаторах, которая помогает отслеживать совместимость и отладку:

```
                  Версии и идентификаторы                   
┏━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Параметр              ┃ Значение                         ┃
┡━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ UUID                  │ 41f82e55ccf5326692b19b36f9dba68e │
│ Версия исходного кода │ 7619.1.26.31.7                   │
│ Версия сборки         │ 15.0.0                           │
└───────────────────────┴──────────────────────────────────┘
```

#### UUID (Universally Unique Identifier)
- Уникальный идентификатор файла
- Используется для связывания исполняемого файла с его отладочными символами (dSYM) - например, отладчики используют UUID для корректной привязки отладочных символов к исполняемому файлу
- При динамическом анализе UUID позволяет идентифицировать версию бинарного файла
- В FAT файлах каждая архитектура имеет свой уникальный UUID

#### Версия исходного кода
- Формат: `MAJOR.MINOR.PATCH.BUILD`
- Пример: `7619.1.26.31.7`
- Показывает версию исходного кода, из которого был собран файл
- Полезно для:
  - Отслеживания изменений в коде
  - Определения совместимости версий
  - Связывания с конкретными коммитами в системе контроля версий

#### Версия сборки
- Формат: `MAJOR.MINOR`
- Пример: `15.0.0`
- Указывает версию операционной системы, для которой была создана сборка
- Важно для:
  - Определения минимальной версии macOS, требуемой для запуска
  - Проверки совместимости с целевой системой
  - Отладки проблем, связанных с версиями ОС

#### Особенности анализа
1. В FAT файлах:
   - Каждая архитектура может иметь разные версии UUID
   - UUID всегда уникален для каждой архитектуры
   - Версии исходного кода и сборки обычно совпадают для всех архитектур

2. Использование в отладке:
   - UUID позволяет найти соответствующий dSYM файл
   - Версии помогают определить, какие изменения могли повлиять на поведение программы
   - В системсах управления версиями UUID помогает отслежить как меняется файл между сборками
   - Информация о сборке помогает воспроизвести проблемы в правильном окружении
   - UUID может быть частбю проверки целостности файла (совместно, с подписью кода) для обаружения подмены.

3. Безопасность:
   - Версии могут указывать на известные уязвимости
   - UUID помогает проверить целостность отладочной информации
   - Информация о сборке важна для определения совместимости с системами безопасности

### FAT Mach-O файлы

FAT (Fat Binary) - это формат, который позволяет объединять несколько Mach-O файлов для разных архитектур в один файл. Например, файл может содержать  две архитектуры: x86_64 и arm64.

#### Структура вывода анализатора
Для каждой архитектуры в FAT файле анализатор будет выводить независимую информацию, проводя независимый анализ по каждой из архитектур:

```
Архитектура 1 из 2: x86_64
        Основная информация        
┏━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┓
┃ Параметр          ┃ Значение    ┃
┡━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━┩
│ Magic             │ MH_CIGAM_64 │
│ Битность          │ 64-bit      │
│ CPU Type          │ x86_64      │
│ CPU Subtype       │ 3           │
│ Тип файла         │ Executable  │
│ Количество команд │ 20          │
│ Размер команд     │ 1264 байт   │
└───────────────────┴─────────────┘
                  Версии и идентификаторы                   
┏━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Параметр              ┃ Значение                         ┃
┡━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ UUID                  │ ef1b6620c0e8372daffaf4381854b9f0 │
│ Версия исходного кода │ 7619.1.26.31.7                   │
│ Версия сборки         │ 15.0.0                           │
└───────────────────────┴──────────────────────────────────┘
                        Флаги                        
┏━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Флаг        ┃ Описание                            ┃
┡━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ MH_NOUNDEFS │ Не содержит неопределенных символов │
│ MH_DYLDLINK │ Динамически связанный               │
│ MH_TWOLEVEL │ Двухуровневое пространство имен     │
│ MH_PIE      │ Position Independent Executable     │
└─────────────┴─────────────────────────────────────┘

```


```
Архитектура 2 из 2: arm64
        Основная информация        
┏━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┓
┃ Параметр          ┃ Значение    ┃
┡━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━┩
│ Magic             │ MH_CIGAM_64 │
│ Битность          │ 64-bit      │
│ CPU Type          │ arm64       │
│ CPU Subtype       │ 2147483650  │
│ Тип файла         │ Executable  │
│ Количество команд │ 20          │
│ Размер команд     │ 1264 байт   │
└───────────────────┴─────────────┘

                  Версии и идентификаторы                   
┏━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Параметр              ┃ Значение                         ┃
┡━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ UUID                  │ 41f82e55ccf5326692b19b36f9dba68e │
│ Версия исходного кода │ 7619.1.26.31.7                   │
│ Версия сборки         │ 15.0.0                           │
└───────────────────────┴──────────────────────────────────┘

                        Флаги                        
┏━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Флаг        ┃ Описание                            ┃
┡━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ MH_NOUNDEFS │ Не содержит неопределенных символов │
│ MH_DYLDLINK │ Динамически связанный               │
│ MH_TWOLEVEL │ Двухуровневое пространство имен     │
│ MH_PIE      │ Position Independent Executable     │
└─────────────┴─────────────────────────────────────┘
```

### Команды загрузки и сегменты

После заголовка Mach-O файла следует массив команд загрузки (Load Commands), которые определяют как и где загружать различные части файла. Каждая команда загрузки имеет следующую базовую структуру:

```c
struct load_command {
    uint32_t cmd;        // Тип команды
    uint32_t cmdsize;    // Размер команды в байтах
};
```

#### Основные типы команд загрузки

1. **LC_SEGMENT_64** (0x19) - Описывает сегмент 64-битного файла:
```c
struct segment_command_64 {
    uint32_t cmd;           // LC_SEGMENT_64
    uint32_t cmdsize;       // Размер команды
    char segname[16];       // Имя сегмента
    uint64_t vmaddr;        // Виртуальный адрес загрузки
    uint64_t vmsize;        // Размер в памяти
    uint64_t fileoff;       // Смещение в файле
    uint64_t filesize;      // Размер в файле
    vm_prot_t maxprot;      // Максимальные права доступа
    vm_prot_t initprot;     // Начальные права доступа
    uint32_t nsects;        // Количество секций
    uint32_t flags;         // Флаги сегмента
};
```

2. **LC_SYMTAB** (0x2) - Таблица символов:
```c
struct symtab_command {
    uint32_t cmd;           // LC_SYMTAB
    uint32_t cmdsize;       // Размер команды
    uint32_t symoff;        // Смещение таблицы символов
    uint32_t nsyms;         // Количество символов
    uint32_t stroff;        // Смещение таблицы строк
    uint32_t strsize;       // Размер таблицы строк
};
```

3. **LC_DYSYMTAB** (0xB) - Динамическая таблица символов:
```c
struct dysymtab_command {
    uint32_t cmd;           // LC_DYSYMTAB
    uint32_t cmdsize;       // Размер команды
    uint32_t ilocalsym;     // Индекс первого локального символа
    uint32_t nlocalsym;     // Количество локальных символов
    uint32_t iextdefsym;    // Индекс первого внешнего символа
    uint32_t nextdefsym;    // Количество внешних символов
    uint32_t iundefsym;     // Индекс первого неопределенного символа
    uint32_t nundefsym;     // Количество неопределенных символов
    uint32_t tocoff;        // Смещение таблицы содержания
    uint32_t ntoc;          // Количество записей в таблице содержания
    uint32_t modtaboff;     // Смещение таблицы модулей
    uint32_t nmodtab;       // Количество записей в таблице модулей
    uint32_t extrefsymoff;  // Смещение таблицы внешних ссылок
    uint32_t nextrefsyms;   // Количество внешних ссылок
    uint32_t indirectsymoff;// Смещение таблицы косвенных символов
    uint32_t nindirectsyms; // Количество косвенных символов
    uint32_t extreloff;     // Смещение таблицы внешних перемещений
    uint32_t nextrel;       // Количество внешних перемещений
    uint32_t locreloff;     // Смещение таблицы локальных перемещений
    uint32_t nlocrel;       // Количество локальных перемещений
};
```

#### Важные сегменты Mach-O

1. **__PAGEZERO** (0x0)
   - Защищенная область нулевого размера
   - Предотвращает доступ к неинициализированной памяти
   - Права доступа: нет доступа

2. **__TEXT** (0x1)
   - Содержит исполняемый код
   - Права доступа: чтение и выполнение
   - Секции:
     - `__text`: Исполняемый код
     - `__stubs`: Заглушки для динамических функций
     - `__stub_helper`: Вспомогательный код для динамических функций
     - `__cstring`: Строковые литералы
     - `__const`: Константы

3. **__DATA** (0x2)
   - Содержит инициализированные данные
   - Права доступа: чтение и запись
   - Секции:
     - `__data`: Инициализированные данные
     - `__bss`: Неинициализированные данные
     - `__common`: Общие переменные
     - `__la_symbol_ptr`: Указатели на динамические символы

4. **__LINKEDIT** (0x3)
   - Содержит информацию для динамического линковщика
   - Права доступа: чтение
   - Содержит:
     - Таблицы символов
     - Информацию о перемещениях
     - Строковые таблицы
     - Информацию о подписи кода

#### Реализация анализа сегментов

В модуле segment_analyzer приводятся классы, целью которых является предоставление функционала, связанного с имплементацией анализа сегментов (и частично секций).
В модуле представлены важнейшие классы: `SegmentAnalyzer`, `Section` и `Segment`.


#### Использование анализа сегментов

Анализ сегментов используется различными компонентами системы:

1. **SecurityAnalyzer**:
   - Проверка NX (Non-Executable Stack) через анализ прав доступа к сегментам
   - Проверка hardening через анализ прав доступа к сегментам __TEXT и __DATA
   - Поиск подозрительных секций с нестандартными правами доступа
   - Анализ флагов сегментов на наличие уязвимостей

2. **EmbeddedDataAnalyzer**:
   - Анализ содержимого секций на наличие встроенных данных
   - Поиск строковых литералов в секции __cstring
   - Анализ Objective-C метаданных
   - Поиск чувствительных данных и криптографических констант
   - Проверка секций на наличие скрытых данных

3. **DebugAnalyzer**:
   - Проверка наличия отладочных секций
   - Анализ DWARF информации
   - Поиск отладочных символов
   - Проверка наличия символов в секции __symbols

4. **SymbolAnalyzer**:
   - Анализ таблицы символов
   - Поиск импортируемых функций
   - Анализ экспортируемых символов
   - Проверка динамических символов

#### Пример вывода анализатора

```
                                            Сводка по сегментам                                           
┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┓
┃ Имя          ┃ VM адрес    ┃ VM размер          ┃ Смещение ┃ Размер      ┃ Защита            ┃ Секции ┃
┡━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━┩
│ __PAGEZERO   │ 0x0         │ 4,294,967,296 байт │ 0        │ 0 байт      │ max=---, init=--- │ 0      │
│ __TEXT       │ 0x100000000 │ 16,384 байт        │ 0        │ 16,384 байт │ max=R-X, init=R-X │ 4      │
│ __DATA_CONST │ 0x100004000 │ 16,384 байт        │ 16384    │ 16,384 байт │ max=RW-, init=RW- │ 1      │
│ __LINKEDIT   │ 0x100008000 │ 16,384 байт        │ 32768    │ 904 байт    │ max=R--, init=R-- │ 0      │
└──────────────┴─────────────┴────────────────────┴──────────┴─────────────┴───────────────────┴────────┘

Секции:
                                Секции в __TEXT                                
┏━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Имя           ┃ Адрес       ┃ Размер ┃ Флаги                                ┃
┡━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ __text        │ 0x100003ee8 │ 128    │ PURE_INSTRUCTIONS, SOME_INSTRUCTIONS │
│ __stubs       │ 0x100003f68 │ 36     │ PURE_INSTRUCTIONS, SOME_INSTRUCTIONS │
│ __cstring     │ 0x100003f8c │ 17     │ -                                    │
│ __unwind_info │ 0x100003fa0 │ 96     │ -                                    │
└───────────────┴─────────────┴────────┴──────────────────────────────────────┘

         Секции в __DATA_CONST          
┏━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━┓
┃ Имя   ┃ Адрес       ┃ Размер ┃ Флаги ┃
┡━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━┩
│ __got │ 0x100004000 │ 32     │ -     │
└───────┴─────────────┴────────┴───────┘
```

#### Особенности анализа

1. **Безопасность**:
   - Проверка прав доступа к сегментам
   - Анализ защитных механизмов (NX, ASLR)
   - Поиск подозрительных секций
   - Проверка флагов сегментов на наличие уязвимостей

2. **Оптимизация**:
   - Кэширование результатов анализа
   - Эффективное хранение информации о сегментах
   - Быстрый доступ к часто используемым данным
   - Оптимизированный парсинг флагов и типов

3. **Расширяемость**:
   - Поддержка новых типов сегментов
   - Возможность добавления дополнительных проверок
   - Гибкая система анализа секций
   - Легкое добавление новых флагов и типов

